# 量化选基模型设计方案

> 基于学术研究与实证回测的程序化基金筛选系统

---

## 文档说明

本文档基于以下学术研究和实证文献整理：

1. **Fama-French 三因子/五因子模型** - 资产定价与风格归因
2. **AQR Factor Momentum研究** - 因子动量策略
3. **NBER Working Paper #29723** - 机器学习预测基金经理能力
4. **SSRN #4887900** - 组合19种预测因子的复合选基模型
5. **BigQuant量化研究** - 风格稳定性与业绩持续性研究
6. **Journal of Financial Econometrics 2023** - ML方法实现2.4%年化超额收益

**重要声明**：本模型仅供参考，投资有风险，请根据自身情况谨慎决策。

---

## 一、模型架构总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         量化选基模型 v1.0                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌───────────┐ │
│  │ 数据采集层   │ →  │ 因子计算层   │ →  │ 综合评分层   │ →  │ 输出层    │ │
│  └──────────────┘    └──────────────┘    └──────────────┘    └───────────┘ │
│         │                   │                   │                   │       │
│    ┌────┴────┐         ┌────┴────┐         ┌────┴────┐         ┌────┴────┐ │
│    │净值数据 │         │业绩因子 │         │加权评分 │         │排名列表 │ │
│    │持仓数据 │         │风险因子 │         │分位排名 │         │买入建议 │ │
│    │基金信息 │         │风格因子 │         │阈值过滤 │         │置信度   │ │
│    │市场数据 │         │动量因子 │         │         │         │         │ │
│    └─────────┘         └─────────┘         └─────────┘         └─────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、评分因子体系

### 2.1 因子分类与权重

基于学术研究，模型采用**四大类11项因子**进行综合评分：

| 因子类别 | 权重 | 包含因子 | 理论依据 |
|---------|------|---------|---------|
| **业绩因子** | 30% | 收益率、Alpha、排名 | 业绩持续性研究 |
| **风险因子** | 25% | 最大回撤、波动率、夏普比率 | 风险调整收益理论 |
| **风格因子** | 20% | 风格稳定性、持仓集中度 | Fama-French模型 |
| **动量因子** | 15% | 资金流向、短期动量 | 因子动量研究 |
| **基础因子** | 10% | 规模、经理任期、费率 | 基金特征研究 |

---

### 2.2 业绩因子（权重30%）

#### 2.2.1 年化收益率评分

```python
def calc_return_score(fund_data):
    """
    收益率评分逻辑
    
    评分维度：
    - 近1年收益率排名百分位
    - 近3年收益率排名百分位
    - 近5年收益率排名百分位（权重最高）
    
    计算公式：
    score = 0.2 * rank_1y + 0.35 * rank_3y + 0.45 * rank_5y
    
    其中 rank_xy 为同类基金中的排名百分位（0-100）
    """
    weights = {
        'return_1y': 0.20,
        'return_3y': 0.35,
        'return_5y': 0.45
    }
    
    # 计算各期收益率在同类中的百分位排名
    rank_1y = percentile_rank(fund_data['return_1y'], category=fund_data['type'])
    rank_3y = percentile_rank(fund_data['return_3y'], category=fund_data['type'])
    rank_5y = percentile_rank(fund_data['return_5y'], category=fund_data['type'])
    
    score = (weights['return_1y'] * rank_1y +
             weights['return_3y'] * rank_3y +
             weights['return_5y'] * rank_5y)
    
    return score  # 0-100分
```

**阈值标准**：
- 优秀：综合排名前25%（≥75分）
- 良好：综合排名前50%（≥50分）
- 合格：综合排名前75%（≥25分）
- 淘汰：综合排名后25%（<25分）

#### 2.2.2 超额收益Alpha评分

```python
def calc_alpha_score(fund_data, benchmark_data, rf_rate=0.02):
    """
    Jensen's Alpha 计算
    
    Alpha = Rp - [Rf + β(Rm - Rf)]
    
    其中：
    - Rp: 基金收益率
    - Rf: 无风险收益率（取1年期国债收益率，约2%）
    - Rm: 基准指数收益率
    - β: 基金相对基准的Beta系数
    
    评分规则：
    - Alpha > 5%: 100分
    - Alpha > 3%: 85分
    - Alpha > 1%: 70分
    - Alpha > 0%: 55分
    - Alpha > -2%: 35分
    - Alpha ≤ -2%: 15分
    """
    # 计算Beta
    cov = np.cov(fund_data['returns'], benchmark_data['returns'])[0][1]
    var = np.var(benchmark_data['returns'])
    beta = cov / var
    
    # 计算Alpha（年化）
    fund_return = fund_data['annual_return']
    benchmark_return = benchmark_data['annual_return']
    alpha = fund_return - (rf_rate + beta * (benchmark_return - rf_rate))
    
    # 评分映射
    if alpha > 0.05:
        return 100
    elif alpha > 0.03:
        return 85
    elif alpha > 0.01:
        return 70
    elif alpha > 0:
        return 55
    elif alpha > -0.02:
        return 35
    else:
        return 15
```

**研究支撑**：
> SSRN #4887900研究表明，过去12个月Alpha是预测未来业绩的重要指标，顶部10%基金年化超额4.56%。

---

### 2.3 风险因子（权重25%）

#### 2.3.1 最大回撤评分

```python
def calc_max_drawdown_score(nav_series, fund_type):
    """
    最大回撤评分
    
    最大回撤 = (前期最高点 - 最低点) / 前期最高点
    
    评分标准（按基金类型差异化）：
    
    股票型基金：
    - 回撤 < 15%: 100分
    - 回撤 < 25%: 80分
    - 回撤 < 35%: 60分
    - 回撤 < 45%: 40分
    - 回撤 ≥ 45%: 20分
    
    混合型基金：
    - 回撤 < 10%: 100分
    - 回撤 < 20%: 80分
    - 回撤 < 30%: 60分
    - 回撤 ≥ 30%: 40分
    
    债券型基金：
    - 回撤 < 3%: 100分
    - 回撤 < 5%: 80分
    - 回撤 < 8%: 60分
    - 回撤 ≥ 8%: 40分
    """
    # 计算滚动最大值
    rolling_max = nav_series.expanding().max()
    drawdown = (rolling_max - nav_series) / rolling_max
    max_drawdown = drawdown.max()
    
    # 根据基金类型选择评分标准
    thresholds = {
        'stock': [(0.15, 100), (0.25, 80), (0.35, 60), (0.45, 40), (1.0, 20)],
        'mixed': [(0.10, 100), (0.20, 80), (0.30, 60), (1.0, 40)],
        'bond': [(0.03, 100), (0.05, 80), (0.08, 60), (1.0, 40)]
    }
    
    for threshold, score in thresholds.get(fund_type, thresholds['mixed']):
        if max_drawdown < threshold:
            return score
    
    return 20
```

#### 2.3.2 夏普比率评分

```python
def calc_sharpe_score(fund_returns, rf_rate=0.02):
    """
    夏普比率评分
    
    Sharpe Ratio = (Rp - Rf) / σp
    
    其中：
    - Rp: 基金年化收益率
    - Rf: 无风险收益率
    - σp: 收益率年化标准差
    
    评分标准：
    - Sharpe > 2.0: 100分（极优秀）
    - Sharpe > 1.5: 90分（优秀）
    - Sharpe > 1.0: 80分（良好）
    - Sharpe > 0.7: 65分（中等偏上）
    - Sharpe > 0.5: 50分（中等）
    - Sharpe > 0.3: 35分（偏弱）
    - Sharpe ≤ 0.3: 20分（差）
    """
    annual_return = (1 + fund_returns.mean()) ** 252 - 1
    annual_std = fund_returns.std() * np.sqrt(252)
    
    sharpe = (annual_return - rf_rate) / annual_std if annual_std > 0 else 0
    
    score_map = [
        (2.0, 100), (1.5, 90), (1.0, 80), (0.7, 65),
        (0.5, 50), (0.3, 35), (float('-inf'), 20)
    ]
    
    for threshold, score in score_map:
        if sharpe > threshold:
            return score
    
    return 20
```

**为什么夏普比率重要**：
> 研究表明，使用Sharpe Ratio优化的深度学习模型能更好地平衡收益与风险，是评估风险调整后收益的核心指标。

#### 2.3.3 索提诺比率评分（补充）

```python
def calc_sortino_score(fund_returns, rf_rate=0.02):
    """
    索提诺比率 - 只考虑下行风险
    
    Sortino Ratio = (Rp - Rf) / σd
    
    其中 σd 只计算负收益的标准差
    
    评分标准与夏普比率类似，但更关注下行保护
    """
    annual_return = (1 + fund_returns.mean()) ** 252 - 1
    
    # 只计算下行波动
    downside_returns = fund_returns[fund_returns < 0]
    downside_std = downside_returns.std() * np.sqrt(252) if len(downside_returns) > 0 else 0.0001
    
    sortino = (annual_return - rf_rate) / downside_std
    
    score_map = [
        (2.5, 100), (2.0, 90), (1.5, 80), (1.0, 65),
        (0.7, 50), (0.4, 35), (float('-inf'), 20)
    ]
    
    for threshold, score in score_map:
        if sortino > threshold:
            return score
    
    return 20
```

---

### 2.4 风格因子（权重20%）

#### 2.4.1 风格稳定性评分（SDS指标）

```python
def calc_style_stability_score(fund_data, lookback_quarters=8):
    """
    风格稳定性评分 (Style Drift Score)
    
    基于Fama-French模型，计算基金在不同时期的风格暴露变化
    
    研究背景：
    BigQuant研究表明，风格稳定的基金更容易预测，
    风格漂移会导致业绩不可预期。
    
    计算方法：
    1. 使用滚动窗口对基金收益进行因子回归
    2. 计算各因子暴露的时间序列方差
    3. 方差越小，风格越稳定
    
    评分规则：
    - SDS < 0.1: 100分（非常稳定）
    - SDS < 0.2: 85分（稳定）
    - SDS < 0.3: 70分（较稳定）
    - SDS < 0.5: 50分（一般）
    - SDS ≥ 0.5: 30分（风格漂移）
    """
    from sklearn.linear_model import LinearRegression
    
    factor_exposures = []
    
    # 滚动计算因子暴露
    for i in range(lookback_quarters):
        quarter_returns = get_quarter_returns(fund_data, quarter=i)
        quarter_factors = get_factor_data(quarter=i)  # SMB, HML, MKT
        
        model = LinearRegression()
        model.fit(quarter_factors, quarter_returns)
        factor_exposures.append(model.coef_)
    
    # 计算风格漂移指数
    sds = np.std(factor_exposures, axis=0).mean()
    
    if sds < 0.1:
        return 100
    elif sds < 0.2:
        return 85
    elif sds < 0.3:
        return 70
    elif sds < 0.5:
        return 50
    else:
        return 30
```

#### 2.4.2 持仓集中度评分

```python
def calc_concentration_score(holdings_data):
    """
    持仓集中度评分
    
    评估指标：
    - 前10大重仓股占比
    - 单一行业占比
    
    过度集中增加非系统性风险
    
    评分规则（前10大持仓占比）：
    - 占比 < 30%: 100分（分散充分）
    - 占比 < 45%: 85分（较分散）
    - 占比 < 60%: 70分（适中）
    - 占比 < 75%: 50分（偏集中）
    - 占比 ≥ 75%: 30分（过度集中）
    """
    top10_ratio = holdings_data['top10_ratio']
    
    if top10_ratio < 0.30:
        return 100
    elif top10_ratio < 0.45:
        return 85
    elif top10_ratio < 0.60:
        return 70
    elif top10_ratio < 0.75:
        return 50
    else:
        return 30
```

---

### 2.5 动量因子（权重15%）

#### 2.5.1 短期动量评分

```python
def calc_momentum_score(nav_series):
    """
    动量因子评分
    
    研究背景：
    AQR研究表明，因子动量具有显著的Alpha，
    且与股票动量相互补充而非替代。
    
    动量指标：
    - 1个月动量（短期趋势）
    - 3个月动量（中期趋势）
    - 6个月动量（中长期趋势）
    
    综合公式：
    momentum_score = 0.3 * mom_1m + 0.4 * mom_3m + 0.3 * mom_6m
    """
    mom_1m = nav_series[-1] / nav_series[-22] - 1  # 约22个交易日
    mom_3m = nav_series[-1] / nav_series[-66] - 1
    mom_6m = nav_series[-1] / nav_series[-132] - 1
    
    # 转换为同类百分位排名
    rank_1m = percentile_rank(mom_1m)
    rank_3m = percentile_rank(mom_3m)
    rank_6m = percentile_rank(mom_6m)
    
    score = 0.3 * rank_1m + 0.4 * rank_3m + 0.3 * rank_6m
    
    return score
```

#### 2.5.2 资金流向评分

```python
def calc_flow_score(fund_data):
    """
    资金流向评分
    
    研究背景：
    NBER研究表明，Fund Flow是预测未来业绩的重要指标之一
    
    指标：
    - 近1月净申购比例
    - 近3月净申购比例
    - 机构持有占比变化
    
    评分逻辑：
    - 适度净流入为佳
    - 过大流入可能摊薄收益
    - 大额流出可能被动卖出
    """
    flow_1m = fund_data['net_flow_1m']  # 净流入/总规模
    flow_3m = fund_data['net_flow_3m']
    
    # 评分：适度流入最佳（0-10%）
    def flow_to_score(flow):
        if 0 < flow < 0.05:
            return 100
        elif 0 < flow < 0.10:
            return 85
        elif -0.05 < flow <= 0:
            return 70
        elif 0.10 <= flow < 0.20:
            return 60
        elif -0.10 < flow <= -0.05:
            return 50
        else:
            return 30  # 大进大出都不好
    
    score = 0.6 * flow_to_score(flow_1m) + 0.4 * flow_to_score(flow_3m)
    
    return score
```

---

### 2.6 基础因子（权重10%）

#### 2.6.1 规模评分

```python
def calc_scale_score(fund_size, fund_type):
    """
    基金规模评分
    
    研究表明：
    - 过小规模：清盘风险、交易冲击成本高
    - 过大规模：策略容量受限、收益被摊薄
    
    最佳规模区间（按类型）：
    - 股票型：5-80亿
    - 混合型：2-100亿
    - 债券型：10-200亿
    - 货币型：100-1000亿
    """
    optimal_ranges = {
        'stock': (5, 80),
        'mixed': (2, 100),
        'bond': (10, 200),
        'money': (100, 1000)
    }
    
    min_size, max_size = optimal_ranges.get(fund_type, (2, 100))
    
    if min_size <= fund_size <= max_size:
        return 100
    elif fund_size < min_size:
        # 过小惩罚
        if fund_size < 1:
            return 20  # 清盘风险
        return 50 + 50 * (fund_size / min_size)
    else:
        # 过大惩罚
        if fund_size > max_size * 3:
            return 40
        return 100 - 30 * ((fund_size - max_size) / max_size)
```

#### 2.6.2 基金经理评分

```python
def calc_manager_score(manager_data):
    """
    基金经理评分
    
    评估维度：
    1. 任职年限（经验）
    2. 管理该基金时长（稳定性）
    3. 历史管理业绩（能力验证）
    4. 是否经历牛熊（周期检验）
    """
    tenure = manager_data['tenure_years']  # 管理本基金年限
    experience = manager_data['total_experience_years']  # 从业总年限
    historical_rank = manager_data['historical_avg_rank']  # 历史平均排名
    
    # 任职年限评分
    if tenure >= 5:
        tenure_score = 100
    elif tenure >= 3:
        tenure_score = 80
    elif tenure >= 2:
        tenure_score = 60
    elif tenure >= 1:
        tenure_score = 40
    else:
        tenure_score = 20
    
    # 经验评分
    if experience >= 10:
        exp_score = 100
    elif experience >= 7:
        exp_score = 85
    elif experience >= 5:
        exp_score = 70
    elif experience >= 3:
        exp_score = 50
    else:
        exp_score = 30
    
    # 历史业绩评分
    perf_score = (1 - historical_rank) * 100  # rank是0-1，越小越好
    
    # 综合评分
    score = 0.4 * tenure_score + 0.3 * exp_score + 0.3 * perf_score
    
    return score
```

#### 2.6.3 费率评分

```python
def calc_fee_score(fund_data):
    """
    费率评分
    
    考虑因素：
    - 管理费（年化）
    - 托管费（年化）
    - 申购费（一次性，按持有1年折算）
    - 赎回费（持有超1年通常为0）
    
    总费用率 = 管理费 + 托管费 + 申购费/持有年限
    """
    management_fee = fund_data['management_fee']
    custody_fee = fund_data['custody_fee']
    purchase_fee = fund_data['purchase_fee'] * 0.1  # 假设第三方平台1折
    
    total_fee = management_fee + custody_fee + purchase_fee
    
    # 评分标准
    if total_fee < 0.8:
        return 100
    elif total_fee < 1.2:
        return 85
    elif total_fee < 1.6:
        return 70
    elif total_fee < 2.0:
        return 55
    else:
        return 40
```

---

## 三、综合评分模型

### 3.1 加权评分计算

```python
class FundScoringModel:
    """
    基金综合评分模型
    """
    
    # 因子权重配置
    WEIGHTS = {
        'performance': {
            'weight': 0.30,
            'sub_factors': {
                'return_score': 0.5,
                'alpha_score': 0.5
            }
        },
        'risk': {
            'weight': 0.25,
            'sub_factors': {
                'max_drawdown_score': 0.35,
                'sharpe_score': 0.40,
                'sortino_score': 0.25
            }
        },
        'style': {
            'weight': 0.20,
            'sub_factors': {
                'stability_score': 0.6,
                'concentration_score': 0.4
            }
        },
        'momentum': {
            'weight': 0.15,
            'sub_factors': {
                'momentum_score': 0.6,
                'flow_score': 0.4
            }
        },
        'fundamental': {
            'weight': 0.10,
            'sub_factors': {
                'scale_score': 0.3,
                'manager_score': 0.4,
                'fee_score': 0.3
            }
        }
    }
    
    def calculate_total_score(self, fund_data):
        """计算综合评分"""
        scores = {}
        
        # 业绩因子
        perf_score = (
            self.WEIGHTS['performance']['sub_factors']['return_score'] * 
            calc_return_score(fund_data) +
            self.WEIGHTS['performance']['sub_factors']['alpha_score'] * 
            calc_alpha_score(fund_data)
        )
        scores['performance'] = perf_score
        
        # 风险因子
        risk_score = (
            self.WEIGHTS['risk']['sub_factors']['max_drawdown_score'] * 
            calc_max_drawdown_score(fund_data) +
            self.WEIGHTS['risk']['sub_factors']['sharpe_score'] * 
            calc_sharpe_score(fund_data) +
            self.WEIGHTS['risk']['sub_factors']['sortino_score'] * 
            calc_sortino_score(fund_data)
        )
        scores['risk'] = risk_score
        
        # 风格因子
        style_score = (
            self.WEIGHTS['style']['sub_factors']['stability_score'] * 
            calc_style_stability_score(fund_data) +
            self.WEIGHTS['style']['sub_factors']['concentration_score'] * 
            calc_concentration_score(fund_data)
        )
        scores['style'] = style_score
        
        # 动量因子
        momentum_score = (
            self.WEIGHTS['momentum']['sub_factors']['momentum_score'] * 
            calc_momentum_score(fund_data) +
            self.WEIGHTS['momentum']['sub_factors']['flow_score'] * 
            calc_flow_score(fund_data)
        )
        scores['momentum'] = momentum_score
        
        # 基础因子
        fundamental_score = (
            self.WEIGHTS['fundamental']['sub_factors']['scale_score'] * 
            calc_scale_score(fund_data) +
            self.WEIGHTS['fundamental']['sub_factors']['manager_score'] * 
            calc_manager_score(fund_data) +
            self.WEIGHTS['fundamental']['sub_factors']['fee_score'] * 
            calc_fee_score(fund_data)
        )
        scores['fundamental'] = fundamental_score
        
        # 加权总分
        total_score = (
            self.WEIGHTS['performance']['weight'] * scores['performance'] +
            self.WEIGHTS['risk']['weight'] * scores['risk'] +
            self.WEIGHTS['style']['weight'] * scores['style'] +
            self.WEIGHTS['momentum']['weight'] * scores['momentum'] +
            self.WEIGHTS['fundamental']['weight'] * scores['fundamental']
        )
        
        return {
            'total_score': total_score,
            'detail_scores': scores,
            'recommendation': self.get_recommendation(total_score)
        }
    
    def get_recommendation(self, score):
        """根据分数给出建议"""
        if score >= 85:
            return {
                'action': 'STRONG_BUY',
                'confidence': 5,
                'description': '强烈推荐，各维度表现优异'
            }
        elif score >= 75:
            return {
                'action': 'BUY',
                'confidence': 4,
                'description': '推荐买入，综合表现良好'
            }
        elif score >= 65:
            return {
                'action': 'HOLD',
                'confidence': 3,
                'description': '可以持有，表现中等偏上'
            }
        elif score >= 50:
            return {
                'action': 'WATCH',
                'confidence': 2,
                'description': '观望为主，有待观察'
            }
        else:
            return {
                'action': 'AVOID',
                'confidence': 1,
                'description': '不推荐，存在明显短板'
            }
```

---

### 3.2 预筛选规则（硬性过滤）

在计算综合评分前，先进行硬性过滤：

```python
class FundPreFilter:
    """
    基金预筛选器 - 硬性条件过滤
    """
    
    FILTER_RULES = {
        # 规模过滤
        'min_size': 1,          # 最小规模1亿
        'max_size': 500,        # 最大规模500亿
        
        # 成立时间
        'min_age_years': 2,     # 至少成立2年
        
        # 基金经理
        'min_manager_tenure': 1,  # 经理任职至少1年
        
        # 业绩门槛
        'min_return_3y_rank': 0.5,  # 3年收益至少前50%
        
        # 回撤控制
        'max_drawdown_limit': {
            'stock': 0.50,
            'mixed': 0.40,
            'bond': 0.15
        }
    }
    
    def filter(self, fund_data):
        """
        返回 True 表示通过筛选
        """
        # 规模检查
        if fund_data['size'] < self.FILTER_RULES['min_size']:
            return False, '规模过小，清盘风险'
        
        if fund_data['size'] > self.FILTER_RULES['max_size']:
            return False, '规模过大，收益可能被摊薄'
        
        # 成立时间检查
        if fund_data['age_years'] < self.FILTER_RULES['min_age_years']:
            return False, '成立时间过短，无法验证'
        
        # 经理任职检查
        if fund_data['manager_tenure'] < self.FILTER_RULES['min_manager_tenure']:
            return False, '基金经理任职时间过短'
        
        # 3年业绩排名检查
        if fund_data['return_3y_rank'] > self.FILTER_RULES['min_return_3y_rank']:
            return False, '3年业绩排名不达标'
        
        # 最大回撤检查
        fund_type = fund_data['type']
        max_dd_limit = self.FILTER_RULES['max_drawdown_limit'].get(fund_type, 0.40)
        if fund_data['max_drawdown'] > max_dd_limit:
            return False, '最大回撤超过限制'
        
        return True, '通过预筛选'
```

---

## 四、4433法则增强版

结合传统4433法则和量化因子，构建增强版筛选策略：

```python
class Enhanced4433Filter:
    """
    4433法则增强版
    
    传统4433:
    - 4: 1年收益前1/4
    - 4: 2年、3年、5年收益前1/4
    - 3: 6个月收益前1/3
    - 3: 3个月收益前1/3
    
    增强版新增:
    - 夏普比率前1/3
    - 最大回撤同类后1/3（即回撤较小的）
    - 风格稳定性前1/2
    """
    
    def check_4433(self, fund_data, category_stats):
        """检查是否满足4433条件"""
        checks = {
            '1年收益前25%': fund_data['rank_1y'] <= 0.25,
            '2年收益前25%': fund_data['rank_2y'] <= 0.25,
            '3年收益前25%': fund_data['rank_3y'] <= 0.25,
            '5年收益前25%': fund_data['rank_5y'] <= 0.25,
            '6月收益前33%': fund_data['rank_6m'] <= 0.33,
            '3月收益前33%': fund_data['rank_3m'] <= 0.33,
            # 增强条件
            '夏普比率前33%': fund_data['sharpe_rank'] <= 0.33,
            '回撤控制前33%': fund_data['drawdown_rank'] <= 0.33,
            '风格稳定前50%': fund_data['style_stability_rank'] <= 0.50,
        }
        
        passed = all(checks.values())
        
        return {
            'passed': passed,
            'checks': checks,
            'pass_count': sum(checks.values()),
            'total_checks': len(checks)
        }
```

---

## 五、模型输出与建议

### 5.1 输出格式

```python
def generate_recommendation_report(scored_funds):
    """
    生成推荐报告
    """
    report = {
        'generated_at': datetime.now().isoformat(),
        'total_analyzed': len(scored_funds),
        'recommendations': {
            'strong_buy': [],   # 得分 ≥ 85
            'buy': [],          # 得分 75-84
            'hold': [],         # 得分 65-74
            'watch': [],        # 得分 50-64
            'avoid': []         # 得分 < 50
        },
        'top_10': [],
        'by_category': {}
    }
    
    for fund in sorted(scored_funds, key=lambda x: x['total_score'], reverse=True):
        action = fund['recommendation']['action'].lower()
        if action in report['recommendations']:
            report['recommendations'][action].append({
                'code': fund['code'],
                'name': fund['name'],
                'score': round(fund['total_score'], 2),
                'detail_scores': fund['detail_scores'],
                'key_metrics': {
                    'return_3y': fund['return_3y'],
                    'sharpe': fund['sharpe_ratio'],
                    'max_drawdown': fund['max_drawdown'],
                    'manager': fund['manager_name']
                }
            })
        
        # Top 10
        if len(report['top_10']) < 10:
            report['top_10'].append(fund)
    
    return report
```

### 5.2 置信度与风险提示

```python
def generate_risk_warning(fund_score_result):
    """
    根据评分结果生成风险提示
    """
    warnings = []
    detail = fund_score_result['detail_scores']
    
    if detail['risk'] < 60:
        warnings.append('⚠️ 风险指标偏弱，注意控制仓位')
    
    if detail['style'] < 50:
        warnings.append('⚠️ 风格稳定性不足，业绩可预测性降低')
    
    if detail['momentum'] < 40:
        warnings.append('⚠️ 短期动量较弱，可能处于调整期')
    
    if detail['fundamental'] < 50:
        warnings.append('⚠️ 基础指标一般，建议观望')
    
    return warnings
```

---

## 六、回测验证框架

### 6.1 回测逻辑

```python
class BacktestFramework:
    """
    模型回测框架
    """
    
    def run_backtest(self, start_date, end_date, rebalance_freq='quarterly'):
        """
        运行回测
        
        参数：
        - start_date: 回测起始日期
        - end_date: 回测结束日期
        - rebalance_freq: 调仓频率（monthly/quarterly/yearly）
        """
        results = {
            'portfolio_returns': [],
            'benchmark_returns': [],
            'holdings_history': [],
            'metrics': {}
        }
        
        current_date = start_date
        while current_date < end_date:
            # 1. 获取当期可用数据
            available_data = get_historical_data(current_date)
            
            # 2. 运行模型筛选
            scored_funds = self.model.score_all_funds(available_data)
            
            # 3. 选择Top N构建组合
            selected = sorted(scored_funds, key=lambda x: x['total_score'])[:10]
            
            # 4. 计算下一期收益
            next_period_return = calculate_portfolio_return(
                selected, 
                current_date, 
                next_rebalance_date(current_date, rebalance_freq)
            )
            
            results['portfolio_returns'].append(next_period_return)
            results['holdings_history'].append(selected)
            
            current_date = next_rebalance_date(current_date, rebalance_freq)
        
        # 计算回测指标
        results['metrics'] = {
            'total_return': calculate_total_return(results['portfolio_returns']),
            'annual_return': calculate_annual_return(results['portfolio_returns']),
            'sharpe_ratio': calculate_sharpe(results['portfolio_returns']),
            'max_drawdown': calculate_max_drawdown(results['portfolio_returns']),
            'win_rate': calculate_win_rate(results['portfolio_returns']),
            'alpha': calculate_alpha(results['portfolio_returns'], results['benchmark_returns'])
        }
        
        return results
```

---

## 七、配置参数表

### 7.1 可调参数

| 参数名 | 默认值 | 说明 | 调整建议 |
|-------|-------|-----|---------|
| `performance_weight` | 0.30 | 业绩因子权重 | 牛市可降低，熊市可提高 |
| `risk_weight` | 0.25 | 风险因子权重 | 保守型提高至0.35 |
| `style_weight` | 0.20 | 风格因子权重 | 长期投资可提高 |
| `momentum_weight` | 0.15 | 动量因子权重 | 短期交易可提高至0.25 |
| `fundamental_weight` | 0.10 | 基础因子权重 | 一般保持不变 |
| `min_size` | 1亿 | 最小规模 | 避免清盘风险 |
| `max_size` | 500亿 | 最大规模 | 防止策略容量受限 |
| `lookback_years` | 3 | 回溯年限 | 至少覆盖一个周期 |

### 7.2 不同投资目标的推荐配置

| 目标类型 | 业绩权重 | 风险权重 | 风格权重 | 动量权重 | 基础权重 |
|---------|---------|---------|---------|---------|---------|
| 稳健保守 | 0.25 | 0.35 | 0.20 | 0.10 | 0.10 |
| 均衡配置 | 0.30 | 0.25 | 0.20 | 0.15 | 0.10 |
| 积极进取 | 0.35 | 0.15 | 0.15 | 0.25 | 0.10 |
| 长期定投 | 0.25 | 0.25 | 0.30 | 0.10 | 0.10 |

---

## 八、参考文献

1. Fama, E. F., & French, K. R. (1993). Common risk factors in the returns on stocks and bonds. *Journal of Financial Economics*.

2. Gupta, T., & Kelly, B. (2019). Factor Momentum Everywhere. *Journal of Portfolio Management*.

3. Kaniel, R., et al. (2023). Machine-Learning the Skill of Mutual Fund Managers. *NBER Working Paper #29723*.

4. Müller, S., & Weber, M. (2024). Forecasting Mutual Fund Performance – Combining Return-Based with Portfolio Holdings-Based Predictors. *SSRN #4887900*.

5. Cai, B., et al. (2023). Machine Learning Mutual Fund Selection. *Journal of Financial Econometrics*.

6. BigQuant研究院. (2023). 风格稳定的绩优股票基金筛选策略.

7. 国泰君安研究所. (2022). 基金收益率分解及其在FOF选基中的应用.

---

## 免责声明

本模型基于历史数据和学术研究构建，不保证未来收益。投资有风险，请根据自身风险承受能力谨慎决策。过往业绩不代表未来表现。

---

*文档版本：1.0*  
*更新日期：2026年1月*
