# 支付宝基金数据采集系统设计方案

> 获取支付宝/蚂蚁财富基金数据并对接量化选基模型

---

## 一、系统概述

### 1.1 目标

构建一个自动化数据采集系统，实现：

1. **数据采集**：获取支付宝/蚂蚁财富平台上可购买的基金完整数据
2. **数据存储**：结构化存储基金净值、持仓、费率等信息
3. **模型对接**：将数据输入量化选基模型，自动生成推荐
4. **定时更新**：每日自动更新数据并重新计算评分

### 1.2 技术方案选择

由于蚂蚁财富没有公开API，我们采用**多数据源聚合方案**：

| 数据源 | 获取方式 | 数据内容 | 优先级 |
|-------|---------|---------|-------|
| **AKShare** | Python库 | 基金净值、基本信息、持仓 | ⭐⭐⭐ 首选 |
| **天天基金API** | HTTP请求 | 实时净值、估算涨跌 | ⭐⭐⭐ 首选 |
| **东方财富网** | 爬虫 | 补充数据 | ⭐⭐ 备用 |
| **蚂蚁财富H5** | 爬虫 | 支付宝特有数据 | ⭐ 补充 |

**核心原理**：支付宝可购买的基金与天天基金、东方财富等平台的基金是同一批公募基金，数据相通。

---

## 二、系统架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         基金数据采集系统 v1.0                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         数据采集层                                    │    │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                │    │
│  │  │ AKShare │  │天天基金  │  │东方财富  │  │蚂蚁财富  │                │    │
│  │  │  API    │  │  API    │  │ 爬虫    │  │  爬虫   │                │    │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘                │    │
│  └───────┼────────────┼────────────┼────────────┼──────────────────────┘    │
│          │            │            │            │                           │
│          └────────────┴─────┬──────┴────────────┘                           │
│                             ▼                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         数据处理层                                    │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │    │
│  │  │  数据清洗    │  │  数据合并    │  │  指标计算    │                  │    │
│  │  │  去重/校验   │  │  多源融合    │  │  因子生成    │                  │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │    │
│  └────────────────────────────┬────────────────────────────────────────┘    │
│                               ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         数据存储层                                    │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │    │
│  │  │  基金基础库  │  │  净值历史库  │  │  评分结果库  │                  │    │
│  │  │  (JSON/DB)  │  │  (CSV/DB)   │  │  (JSON/DB)  │                  │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │    │
│  └────────────────────────────┬────────────────────────────────────────┘    │
│                               ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         应用层                                        │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                  │    │
│  │  │ 量化选基模型 │  │  每日报告    │  │  通知推送    │                  │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、数据采集模块详细设计

### 3.1 AKShare 数据采集器

AKShare 是首选数据源，提供稳定的基金数据接口。

```python
# src/collector/akshare_collector.py

import akshare as ak
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import time
import logging

logger = logging.getLogger(__name__)


class AKShareCollector:
    """
    AKShare 基金数据采集器
    
    主要接口：
    - fund_name_em: 所有基金列表
    - fund_info_index_em: 指数基金详情
    - fund_open_fund_info_em: 开放式基金历史净值
    - fund_portfolio_hold_em: 基金持仓数据
    """
    
    def __init__(self, request_interval: float = 0.5):
        """
        初始化采集器
        
        Args:
            request_interval: 请求间隔（秒），避免被限流
        """
        self.request_interval = request_interval
        self._last_request_time = 0
    
    def _rate_limit(self):
        """请求限流"""
        elapsed = time.time() - self._last_request_time
        if elapsed < self.request_interval:
            time.sleep(self.request_interval - elapsed)
        self._last_request_time = time.time()
    
    def get_all_funds(self) -> pd.DataFrame:
        """
        获取所有基金列表
        
        Returns:
            DataFrame with columns:
            - 基金代码
            - 基金简称
            - 基金类型
            - 拼音简称
        """
        self._rate_limit()
        try:
            df = ak.fund_name_em()
            logger.info(f"获取基金列表成功，共 {len(df)} 只基金")
            return df
        except Exception as e:
            logger.error(f"获取基金列表失败: {e}")
            raise
    
    def get_fund_basic_info(self, fund_code: str) -> Dict:
        """
        获取单只基金基本信息
        
        Args:
            fund_code: 基金代码
            
        Returns:
            Dict containing:
            - 基金全称
            - 基金类型
            - 成立日期
            - 基金规模
            - 基金经理
            - 管理费率
            - 托管费率
            - 业绩比较基准
        """
        self._rate_limit()
        try:
            # 使用雪球接口获取详细信息
            df = ak.fund_individual_basic_info_xq(symbol=fund_code)
            
            # 转换为字典
            info = {}
            for _, row in df.iterrows():
                info[row['item']] = row['value']
            
            return info
        except Exception as e:
            logger.error(f"获取基金 {fund_code} 基本信息失败: {e}")
            return {}
    
    def get_fund_nav_history(
        self, 
        fund_code: str, 
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> pd.DataFrame:
        """
        获取基金历史净值
        
        Args:
            fund_code: 基金代码
            start_date: 起始日期 (YYYY-MM-DD)
            end_date: 结束日期 (YYYY-MM-DD)
            
        Returns:
            DataFrame with columns:
            - 净值日期
            - 单位净值
            - 累计净值
            - 日增长率
        """
        self._rate_limit()
        try:
            df = ak.fund_open_fund_info_em(symbol=fund_code, indicator="单位净值走势")
            
            # 转换日期格式
            df['净值日期'] = pd.to_datetime(df['净值日期'])
            
            # 日期过滤
            if start_date:
                df = df[df['净值日期'] >= start_date]
            if end_date:
                df = df[df['净值日期'] <= end_date]
            
            return df.sort_values('净值日期')
        except Exception as e:
            logger.error(f"获取基金 {fund_code} 净值历史失败: {e}")
            return pd.DataFrame()
    
    def get_fund_holdings(self, fund_code: str, year: str, quarter: str) -> pd.DataFrame:
        """
        获取基金持仓数据
        
        Args:
            fund_code: 基金代码
            year: 年份
            quarter: 季度 (1, 2, 3, 4)
            
        Returns:
            DataFrame with columns:
            - 序号
            - 股票代码
            - 股票名称
            - 占净值比例
            - 持股数(万股)
            - 持仓市值(万元)
        """
        self._rate_limit()
        try:
            df = ak.fund_portfolio_hold_em(
                symbol=fund_code, 
                date=f"{year}年{quarter}季度"
            )
            return df
        except Exception as e:
            logger.error(f"获取基金 {fund_code} 持仓数据失败: {e}")
            return pd.DataFrame()
    
    def get_index_fund_info(self) -> pd.DataFrame:
        """
        获取所有指数基金信息（含各期涨跌幅）
        
        Returns:
            DataFrame with columns:
            - 基金代码
            - 基金简称
            - 日期
            - 单位净值
            - 累计净值
            - 近1周、近1月、近3月、近6月、近1年涨跌幅
        """
        self._rate_limit()
        try:
            df = ak.fund_info_index_em()
            logger.info(f"获取指数基金列表成功，共 {len(df)} 只")
            return df
        except Exception as e:
            logger.error(f"获取指数基金列表失败: {e}")
            return pd.DataFrame()
    
    def get_fund_scale_history(self, fund_code: str) -> pd.DataFrame:
        """
        获取基金规模变化历史
        """
        self._rate_limit()
        try:
            df = ak.fund_open_fund_info_em(symbol=fund_code, indicator="规模变动")
            return df
        except Exception as e:
            logger.error(f"获取基金 {fund_code} 规模历史失败: {e}")
            return pd.DataFrame()
```

### 3.2 天天基金实时数据采集器

```python
# src/collector/eastmoney_collector.py

import requests
import json
import re
from typing import Dict, List, Optional
import time
import logging

logger = logging.getLogger(__name__)


class EastMoneyCollector:
    """
    天天基金网数据采集器
    
    主要接口：
    - 基金列表: fund.eastmoney.com/js/fundcode_search.js
    - 实时估值: fundgz.1234567.com.cn/js/{code}.js
    - 详细数据: fund.eastmoney.com/pingzhongdata/{code}.js
    """
    
    BASE_HEADERS = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Referer': 'http://fund.eastmoney.com/',
        'Accept': '*/*',
        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    }
    
    def __init__(self, request_interval: float = 0.3):
        self.request_interval = request_interval
        self._last_request_time = 0
        self.session = requests.Session()
        self.session.headers.update(self.BASE_HEADERS)
    
    def _rate_limit(self):
        elapsed = time.time() - self._last_request_time
        if elapsed < self.request_interval:
            time.sleep(self.request_interval - elapsed)
        self._last_request_time = time.time()
    
    def get_fund_list(self) -> List[Dict]:
        """
        获取所有基金列表
        
        Returns:
            List of dicts:
            - code: 基金代码
            - abbr: 拼音简称
            - name: 基金名称
            - type: 基金类型
            - pinyin: 全拼
        """
        self._rate_limit()
        url = "http://fund.eastmoney.com/js/fundcode_search.js"
        
        try:
            response = self.session.get(url, timeout=10)
            response.encoding = 'utf-8'
            
            # 解析 JavaScript 变量
            # 格式: var r = [["000001","HXCZHH","华夏成长混合","混合型-灵活","HUAXIACHENGZHANGHUNHE"],...]
            content = response.text
            match = re.search(r'var r = (\[.*?\]);', content, re.S)
            
            if match:
                data = json.loads(match.group(1))
                funds = []
                for item in data:
                    funds.append({
                        'code': item[0],
                        'abbr': item[1],
                        'name': item[2],
                        'type': item[3],
                        'pinyin': item[4]
                    })
                logger.info(f"获取基金列表成功，共 {len(funds)} 只")
                return funds
            
            return []
        except Exception as e:
            logger.error(f"获取基金列表失败: {e}")
            return []
    
    def get_fund_realtime(self, fund_code: str) -> Optional[Dict]:
        """
        获取基金实时估值数据
        
        Args:
            fund_code: 基金代码
            
        Returns:
            Dict containing:
            - fundcode: 基金代码
            - name: 基金名称
            - jzrq: 净值日期
            - dwjz: 单位净值（上一交易日）
            - gsz: 估算净值（实时）
            - gszzl: 估算涨跌幅（百分比）
            - gztime: 估算时间
        """
        self._rate_limit()
        url = f"http://fundgz.1234567.com.cn/js/{fund_code}.js"
        
        try:
            response = self.session.get(url, timeout=10)
            response.encoding = 'utf-8'
            
            # 解析 JSONP
            # 格式: jsonpgz({"fundcode":"000001","name":"华夏成长混合",...});
            content = response.text
            match = re.search(r'jsonpgz\((.*)\)', content)
            
            if match:
                data = json.loads(match.group(1))
                return data
            
            return None
        except Exception as e:
            logger.error(f"获取基金 {fund_code} 实时数据失败: {e}")
            return None
    
    def get_fund_detail(self, fund_code: str) -> Dict:
        """
        获取基金详细数据（包括历史净值、持仓等）
        
        Args:
            fund_code: 基金代码
            
        Returns:
            Dict containing various fund data
        """
        self._rate_limit()
        url = f"http://fund.eastmoney.com/pingzhongdata/{fund_code}.js"
        
        try:
            response = self.session.get(url, timeout=10)
            response.encoding = 'utf-8'
            content = response.text
            
            data = {}
            
            # 解析各个变量
            patterns = {
                'fS_name': r'var fS_name = "(.+?)";',  # 基金名称
                'fS_code': r'var fS_code = "(.+?)";',  # 基金代码
                'fund_sourceRate': r'var fund_sourceRate="(.+?)";',  # 原申购费率
                'fund_Rate': r'var fund_Rate="(.+?)";',  # 现申购费率
                'fund_minsg': r'var fund_minsg="(.+?)";',  # 最小申购金额
                'stockCodes': r'var stockCodes=(\[.*?\]);',  # 持仓股票代码
                'zqCodes': r'var zqCodes="(.+?)";',  # 债券代码
                'syl_1n': r'var syl_1n="(.+?)";',  # 近1年收益率
                'syl_6y': r'var syl_6y="(.+?)";',  # 近6月收益率
                'syl_3y': r'var syl_3y="(.+?)";',  # 近3月收益率
                'syl_1y': r'var syl_1y="(.+?)";',  # 近1月收益率
            }
            
            for key, pattern in patterns.items():
                match = re.search(pattern, content)
                if match:
                    value = match.group(1)
                    try:
                        data[key] = json.loads(value) if value.startswith('[') else value
                    except:
                        data[key] = value
            
            # 解析复杂数据结构
            # 历史净值数据
            nav_pattern = r'var Data_netWorthTrend = (\[.*?\]);'
            match = re.search(nav_pattern, content, re.S)
            if match:
                try:
                    data['nav_history'] = json.loads(match.group(1))
                except:
                    pass
            
            # 持仓数据
            holdings_pattern = r'var stockCodesNew=(\[.*?\]);'
            match = re.search(holdings_pattern, content, re.S)
            if match:
                try:
                    data['holdings'] = json.loads(match.group(1))
                except:
                    pass
            
            return data
        except Exception as e:
            logger.error(f"获取基金 {fund_code} 详细数据失败: {e}")
            return {}
    
    def get_fund_performance_rank(self, fund_type: str = 'all') -> pd.DataFrame:
        """
        获取基金业绩排名
        
        Args:
            fund_type: 基金类型 (all, gp-股票, hh-混合, zq-债券, zs-指数)
        """
        self._rate_limit()
        
        type_map = {
            'all': '',
            'stock': 'gp',
            'mixed': 'hh',
            'bond': 'zq',
            'index': 'zs'
        }
        
        ft = type_map.get(fund_type, '')
        
        url = f"http://fund.eastmoney.com/data/rankhandler.aspx"
        params = {
            'op': 'ph',
            'dt': 'kf',
            'ft': ft,
            'rs': '',
            'gs': '0',
            'sc': '1nzf',
            'st': 'desc',
            'sd': '',
            'ed': '',
            'qdii': '',
            'tabSubtype': ',,,,,',
            'pi': '1',
            'pn': '500',  # 每页数量
            'dx': '1',
            'v': '0.123456'
        }
        
        try:
            response = self.session.get(url, params=params, timeout=15)
            response.encoding = 'utf-8'
            
            # 解析返回数据
            content = response.text
            # 格式: var rankData = {datas:["000001,华夏成长,...",...]}
            match = re.search(r'var rankData = ({.*?});', content, re.S)
            
            if match:
                data = json.loads(match.group(1))
                funds_data = []
                
                for item in data.get('datas', []):
                    parts = item.split(',')
                    if len(parts) >= 20:
                        funds_data.append({
                            'code': parts[0],
                            'name': parts[1],
                            'nav_date': parts[3],
                            'nav': float(parts[4]) if parts[4] else None,
                            'acc_nav': float(parts[5]) if parts[5] else None,
                            'return_1d': float(parts[6]) if parts[6] else None,
                            'return_1w': float(parts[7]) if parts[7] else None,
                            'return_1m': float(parts[8]) if parts[8] else None,
                            'return_3m': float(parts[9]) if parts[9] else None,
                            'return_6m': float(parts[10]) if parts[10] else None,
                            'return_1y': float(parts[11]) if parts[11] else None,
                            'return_2y': float(parts[12]) if parts[12] else None,
                            'return_3y': float(parts[13]) if parts[13] else None,
                            'return_ytd': float(parts[14]) if parts[14] else None,
                            'return_since_inception': float(parts[15]) if parts[15] else None,
                        })
                
                return pd.DataFrame(funds_data)
            
            return pd.DataFrame()
        except Exception as e:
            logger.error(f"获取基金排名失败: {e}")
            return pd.DataFrame()
```

### 3.3 支付宝可购基金过滤器

```python
# src/collector/alipay_filter.py

import pandas as pd
from typing import List, Set
import logging

logger = logging.getLogger(__name__)


class AlipayFundFilter:
    """
    支付宝可购基金过滤器
    
    支付宝（蚂蚁财富）平台上可购买的基金需满足以下条件：
    1. 公募基金（非私募）
    2. 开放申购状态
    3. 非QDII（部分QDII可能受限）
    4. 非分级基金（已整改）
    5. 规模通常 > 5000万
    
    由于蚂蚁财富没有公开API，我们通过以下方式确定可购基金：
    1. 从天天基金获取开放申购的基金列表
    2. 排除特定类型（封闭期基金、定开基金等）
    3. 定期更新可购基金白名单
    """
    
    # 需要排除的基金类型关键词
    EXCLUDE_KEYWORDS = [
        '封闭', '定开', '定期开放', '持有期',
        '三年', '五年', '两年', 
        'LOF', '分级', '理财',
    ]
    
    # 需要排除的基金代码前缀（某些特殊类型）
    EXCLUDE_PREFIXES = [
        '5',   # 场内基金（ETF）- 支付宝可购买联接基金但不能买场内ETF
    ]
    
    def __init__(self):
        self._purchasable_funds: Set[str] = set()
        self._last_update = None
    
    def filter_purchasable(self, fund_list: pd.DataFrame) -> pd.DataFrame:
        """
        过滤出支付宝可购买的基金
        
        Args:
            fund_list: 完整基金列表，需包含 'code', 'name', 'type' 列
            
        Returns:
            过滤后的可购基金列表
        """
        if fund_list.empty:
            return fund_list
        
        mask = pd.Series([True] * len(fund_list), index=fund_list.index)
        
        # 1. 排除特定关键词
        for keyword in self.EXCLUDE_KEYWORDS:
            mask &= ~fund_list['name'].str.contains(keyword, na=False)
        
        # 2. 排除特定前缀
        for prefix in self.EXCLUDE_PREFIXES:
            mask &= ~fund_list['code'].str.startswith(prefix)
        
        # 3. 只保留主要基金类型
        allowed_types = [
            '股票型', '混合型', '债券型', '指数型',
            '货币型', 'QDII', 'FOF',
            '股票指数', '联接基金',
        ]
        
        def check_type(t):
            if pd.isna(t):
                return False
            return any(at in str(t) for at in allowed_types)
        
        mask &= fund_list['type'].apply(check_type)
        
        result = fund_list[mask].copy()
        logger.info(f"过滤后可购基金数量: {len(result)} / {len(fund_list)}")
        
        return result
    
    def get_fund_purchase_status(self, fund_code: str) -> Dict:
        """
        检查单只基金的申购状态
        
        Returns:
            Dict with:
            - purchasable: bool
            - min_amount: 最小申购金额
            - max_amount: 最大申购金额（每日）
            - fee_rate: 申购费率
        """
        # 这里可以调用天天基金API获取申购状态
        try:
            import akshare as ak
            status_df = ak.fund_purchase_em()
            
            fund_status = status_df[status_df['基金代码'] == fund_code]
            
            if not fund_status.empty:
                row = fund_status.iloc[0]
                return {
                    'purchasable': row.get('申购状态') == '开放申购',
                    'min_amount': row.get('起购金额'),
                    'fee_rate': row.get('手续费'),
                    'fund_type': row.get('基金类型')
                }
            
            return {'purchasable': False, 'reason': '未找到基金'}
        except Exception as e:
            logger.error(f"检查基金 {fund_code} 申购状态失败: {e}")
            return {'purchasable': False, 'reason': str(e)}
    
    def categorize_funds(self, fund_list: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        """
        将基金按类型分类（用于分类筛选）
        """
        categories = {
            'stock': fund_list[fund_list['type'].str.contains('股票', na=False)],
            'mixed': fund_list[fund_list['type'].str.contains('混合', na=False)],
            'bond': fund_list[fund_list['type'].str.contains('债券', na=False)],
            'index': fund_list[fund_list['type'].str.contains('指数|联接', na=False)],
            'money': fund_list[fund_list['type'].str.contains('货币', na=False)],
            'qdii': fund_list[fund_list['type'].str.contains('QDII', na=False)],
            'fof': fund_list[fund_list['type'].str.contains('FOF', na=False)],
        }
        
        return categories
```

---

## 四、数据处理与指标计算

### 4.1 数据处理器

```python
# src/processor/fund_processor.py

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)


class FundDataProcessor:
    """
    基金数据处理器
    
    功能：
    1. 数据清洗与标准化
    2. 计算衍生指标（收益率、风险指标等）
    3. 计算因子值
    """
    
    def __init__(self, rf_rate: float = 0.02):
        """
        Args:
            rf_rate: 无风险收益率（年化）
        """
        self.rf_rate = rf_rate
    
    def process_nav_data(self, nav_df: pd.DataFrame) -> pd.DataFrame:
        """
        处理净值数据
        
        输入列: 净值日期, 单位净值, 累计净值
        输出新增列: daily_return, cumulative_return
        """
        df = nav_df.copy()
        
        # 确保日期排序
        df = df.sort_values('净值日期')
        
        # 计算日收益率
        df['daily_return'] = df['单位净值'].pct_change()
        
        # 计算累计收益率
        df['cumulative_return'] = (1 + df['daily_return']).cumprod() - 1
        
        return df
    
    def calculate_returns(self, nav_series: pd.Series) -> Dict[str, float]:
        """
        计算各期间收益率
        
        Returns:
            Dict with keys: return_1m, return_3m, return_6m, return_1y, return_3y, return_5y
        """
        if len(nav_series) < 22:
            return {}
        
        latest = nav_series.iloc[-1]
        
        periods = {
            'return_1m': 22,    # 约1个月交易日
            'return_3m': 66,
            'return_6m': 132,
            'return_1y': 252,
            'return_2y': 504,
            'return_3y': 756,
            'return_5y': 1260,
        }
        
        returns = {}
        for key, days in periods.items():
            if len(nav_series) > days:
                old_nav = nav_series.iloc[-days-1]
                returns[key] = (latest / old_nav - 1) * 100  # 百分比
            else:
                returns[key] = None
        
        return returns
    
    def calculate_risk_metrics(self, returns_series: pd.Series) -> Dict[str, float]:
        """
        计算风险指标
        
        Returns:
            Dict with keys:
            - volatility: 年化波动率
            - max_drawdown: 最大回撤
            - sharpe_ratio: 夏普比率
            - sortino_ratio: 索提诺比率
            - var_95: 95% VaR
            - beta: Beta系数（需要基准数据）
        """
        if len(returns_series) < 30:
            return {}
        
        # 去除空值
        returns = returns_series.dropna()
        
        # 年化波动率
        volatility = returns.std() * np.sqrt(252) * 100
        
        # 最大回撤
        cumulative = (1 + returns).cumprod()
        rolling_max = cumulative.expanding().max()
        drawdown = (rolling_max - cumulative) / rolling_max
        max_drawdown = drawdown.max() * 100
        
        # 年化收益率
        annual_return = (1 + returns.mean()) ** 252 - 1
        
        # 夏普比率
        daily_rf = (1 + self.rf_rate) ** (1/252) - 1
        excess_returns = returns - daily_rf
        sharpe_ratio = (excess_returns.mean() / returns.std()) * np.sqrt(252) if returns.std() > 0 else 0
        
        # 索提诺比率（只考虑下行风险）
        downside_returns = returns[returns < 0]
        downside_std = downside_returns.std() * np.sqrt(252) if len(downside_returns) > 0 else 0.0001
        sortino_ratio = (annual_return - self.rf_rate) / downside_std
        
        # VaR (95%)
        var_95 = np.percentile(returns, 5) * 100
        
        return {
            'volatility': round(volatility, 2),
            'max_drawdown': round(max_drawdown, 2),
            'sharpe_ratio': round(sharpe_ratio, 2),
            'sortino_ratio': round(sortino_ratio, 2),
            'var_95': round(var_95, 2),
            'annual_return': round(annual_return * 100, 2)
        }
    
    def calculate_alpha_beta(
        self, 
        fund_returns: pd.Series, 
        benchmark_returns: pd.Series
    ) -> Dict[str, float]:
        """
        计算 Alpha 和 Beta
        
        使用 CAPM 模型:
        R_fund = Alpha + Beta * R_benchmark + epsilon
        """
        if len(fund_returns) != len(benchmark_returns):
            # 对齐数据
            aligned = pd.concat([fund_returns, benchmark_returns], axis=1).dropna()
            if len(aligned) < 60:
                return {'alpha': None, 'beta': None}
            fund_returns = aligned.iloc[:, 0]
            benchmark_returns = aligned.iloc[:, 1]
        
        # 计算 Beta
        cov = np.cov(fund_returns, benchmark_returns)[0][1]
        var = np.var(benchmark_returns)
        beta = cov / var if var > 0 else 1
        
        # 计算 Alpha (年化)
        fund_annual = (1 + fund_returns.mean()) ** 252 - 1
        benchmark_annual = (1 + benchmark_returns.mean()) ** 252 - 1
        alpha = fund_annual - (self.rf_rate + beta * (benchmark_annual - self.rf_rate))
        
        return {
            'alpha': round(alpha * 100, 2),  # 百分比
            'beta': round(beta, 2)
        }
    
    def calculate_ranking_percentile(
        self, 
        fund_value: float, 
        category_values: pd.Series,
        ascending: bool = False
    ) -> float:
        """
        计算在同类中的百分位排名
        
        Args:
            fund_value: 基金的指标值
            category_values: 同类基金的指标值Series
            ascending: True表示值越小越好（如回撤）
            
        Returns:
            百分位排名 (0-1, 0.1表示前10%)
        """
        if ascending:
            rank = (category_values < fund_value).sum() / len(category_values)
        else:
            rank = (category_values > fund_value).sum() / len(category_values)
        
        return round(rank, 4)
```

### 4.2 综合数据采集器

```python
# src/collector/fund_data_collector.py

import pandas as pd
from typing import Dict, List, Optional
from datetime import datetime
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed

from .akshare_collector import AKShareCollector
from .eastmoney_collector import EastMoneyCollector
from .alipay_filter import AlipayFundFilter
from ..processor.fund_processor import FundDataProcessor

logger = logging.getLogger(__name__)


class FundDataCollector:
    """
    综合基金数据采集器
    
    整合多个数据源，提供统一的数据采集接口
    """
    
    def __init__(self):
        self.akshare = AKShareCollector()
        self.eastmoney = EastMoneyCollector()
        self.alipay_filter = AlipayFundFilter()
        self.processor = FundDataProcessor()
    
    def collect_all_funds(self, filter_purchasable: bool = True) -> pd.DataFrame:
        """
        采集所有基金数据
        
        Args:
            filter_purchasable: 是否只返回支付宝可购基金
            
        Returns:
            完整基金列表DataFrame
        """
        # 1. 获取基金列表
        fund_list = self.akshare.get_all_funds()
        
        # 2. 过滤可购基金
        if filter_purchasable:
            fund_list = self.alipay_filter.filter_purchasable(fund_list)
        
        # 3. 补充业绩排名数据
        performance = self.eastmoney.get_fund_performance_rank()
        
        # 4. 合并数据
        if not performance.empty:
            fund_list = fund_list.merge(
                performance,
                left_on='基金代码',
                right_on='code',
                how='left'
            )
        
        return fund_list
    
    def collect_fund_detail(self, fund_code: str) -> Dict:
        """
        采集单只基金详细数据
        """
        result = {
            'code': fund_code,
            'collected_at': datetime.now().isoformat()
        }
        
        # 1. 基本信息
        basic_info = self.akshare.get_fund_basic_info(fund_code)
        result['basic_info'] = basic_info
        
        # 2. 实时数据
        realtime = self.eastmoney.get_fund_realtime(fund_code)
        result['realtime'] = realtime
        
        # 3. 净值历史
        nav_history = self.akshare.get_fund_nav_history(fund_code)
        if not nav_history.empty:
            nav_history = self.processor.process_nav_data(nav_history)
            result['nav_history'] = nav_history.to_dict('records')
            
            # 计算收益率
            result['returns'] = self.processor.calculate_returns(nav_history['单位净值'])
            
            # 计算风险指标
            result['risk_metrics'] = self.processor.calculate_risk_metrics(
                nav_history['daily_return']
            )
        
        # 4. 持仓数据
        year = datetime.now().year
        quarter = (datetime.now().month - 1) // 3
        if quarter == 0:
            year -= 1
            quarter = 4
        
        holdings = self.akshare.get_fund_holdings(fund_code, str(year), str(quarter))
        if not holdings.empty:
            result['holdings'] = holdings.to_dict('records')
            # 计算持仓集中度
            if '占净值比例' in holdings.columns:
                top10 = holdings.head(10)['占净值比例'].str.rstrip('%').astype(float).sum()
                result['concentration'] = {'top10_ratio': top10}
        
        # 5. 详细数据（天天基金）
        detail = self.eastmoney.get_fund_detail(fund_code)
        result['detail'] = detail
        
        return result
    
    def batch_collect_details(
        self, 
        fund_codes: List[str], 
        max_workers: int = 5
    ) -> Dict[str, Dict]:
        """
        批量采集基金详细数据
        
        Args:
            fund_codes: 基金代码列表
            max_workers: 并发线程数
            
        Returns:
            Dict[fund_code, fund_detail]
        """
        results = {}
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_code = {
                executor.submit(self.collect_fund_detail, code): code 
                for code in fund_codes
            }
            
            for future in as_completed(future_to_code):
                code = future_to_code[future]
                try:
                    result = future.result()
                    results[code] = result
                    logger.info(f"采集基金 {code} 成功")
                except Exception as e:
                    logger.error(f"采集基金 {code} 失败: {e}")
                    results[code] = {'error': str(e)}
        
        return results
```

---

## 五、模型对接模块

### 5.1 选基模型适配器

```python
# src/model/model_adapter.py

import pandas as pd
import numpy as np
from typing import Dict, List
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class FundScoringModelAdapter:
    """
    将采集的数据转换为选基模型输入格式
    """
    
    def __init__(self, weights: Dict = None):
        """
        Args:
            weights: 自定义因子权重
        """
        self.weights = weights or {
            'performance': 0.30,
            'risk': 0.25,
            'style': 0.20,
            'momentum': 0.15,
            'fundamental': 0.10
        }
    
    def prepare_model_input(self, fund_detail: Dict, category_stats: Dict = None) -> Dict:
        """
        将采集的基金数据转换为模型输入格式
        
        Args:
            fund_detail: 采集的基金详细数据
            category_stats: 同类基金统计数据（用于计算排名）
            
        Returns:
            模型输入格式的数据
        """
        input_data = {
            'code': fund_detail.get('code'),
            'name': fund_detail.get('realtime', {}).get('name', ''),
            'collected_at': fund_detail.get('collected_at'),
        }
        
        # 1. 业绩数据
        returns = fund_detail.get('returns', {})
        input_data['performance'] = {
            'return_1m': returns.get('return_1m'),
            'return_3m': returns.get('return_3m'),
            'return_6m': returns.get('return_6m'),
            'return_1y': returns.get('return_1y'),
            'return_3y': returns.get('return_3y'),
            'return_5y': returns.get('return_5y'),
        }
        
        # 2. 风险数据
        risk = fund_detail.get('risk_metrics', {})
        input_data['risk'] = {
            'volatility': risk.get('volatility'),
            'max_drawdown': risk.get('max_drawdown'),
            'sharpe_ratio': risk.get('sharpe_ratio'),
            'sortino_ratio': risk.get('sortino_ratio'),
            'var_95': risk.get('var_95'),
        }
        
        # 3. 基本信息
        basic = fund_detail.get('basic_info', {})
        input_data['fundamental'] = {
            'fund_size': self._parse_size(basic.get('基金规模', '0')),
            'manager_tenure': self._parse_tenure(basic.get('基金经理任职时间', '')),
            'management_fee': self._parse_fee(basic.get('管理费率', '0')),
            'custody_fee': self._parse_fee(basic.get('托管费率', '0')),
            'fund_type': basic.get('基金类型', ''),
            'inception_date': basic.get('成立日期', ''),
        }
        
        # 4. 持仓数据
        concentration = fund_detail.get('concentration', {})
        input_data['style'] = {
            'top10_ratio': concentration.get('top10_ratio', 0),
            # 风格稳定性需要更多历史数据计算
        }
        
        # 5. 动量数据
        realtime = fund_detail.get('realtime', {})
        input_data['momentum'] = {
            'estimate_change': float(realtime.get('gszzl', 0)) if realtime else 0,
            # 资金流向需要额外数据
        }
        
        return input_data
    
    def _parse_size(self, size_str: str) -> float:
        """解析规模字符串为亿元"""
        try:
            if '亿' in size_str:
                return float(size_str.replace('亿', '').strip())
            elif '万' in size_str:
                return float(size_str.replace('万', '').strip()) / 10000
            return float(size_str)
        except:
            return 0
    
    def _parse_tenure(self, tenure_str: str) -> float:
        """解析任职时间为年"""
        try:
            years = 0
            if '年' in tenure_str:
                years += int(tenure_str.split('年')[0])
            if '天' in tenure_str:
                days = int(tenure_str.split('年')[-1].replace('天', '').strip())
                years += days / 365
            return years
        except:
            return 0
    
    def _parse_fee(self, fee_str: str) -> float:
        """解析费率字符串为小数"""
        try:
            return float(fee_str.replace('%', '').strip()) / 100
        except:
            return 0
    
    def calculate_score(self, input_data: Dict, category_stats: Dict = None) -> Dict:
        """
        计算基金综合评分
        
        注意：这里使用简化版评分逻辑
        完整版请参考 量化选基模型设计方案.md
        """
        scores = {}
        
        # 业绩评分
        perf = input_data.get('performance', {})
        perf_score = 0
        count = 0
        for key in ['return_1y', 'return_3y', 'return_5y']:
            if perf.get(key) is not None:
                # 简化：假设收益率>15%为100分，线性递减
                score = min(100, max(0, perf[key] / 0.15 * 50 + 50))
                perf_score += score
                count += 1
        scores['performance'] = perf_score / count if count > 0 else 50
        
        # 风险评分
        risk = input_data.get('risk', {})
        risk_score = 0
        
        # 夏普比率评分
        sharpe = risk.get('sharpe_ratio', 0)
        if sharpe > 2:
            risk_score += 100
        elif sharpe > 1:
            risk_score += 80
        elif sharpe > 0.5:
            risk_score += 60
        else:
            risk_score += 40
        
        # 最大回撤评分
        mdd = risk.get('max_drawdown', 30)
        if mdd < 15:
            risk_score += 100
        elif mdd < 25:
            risk_score += 80
        elif mdd < 35:
            risk_score += 60
        else:
            risk_score += 40
        
        scores['risk'] = risk_score / 2
        
        # 基础评分
        fund = input_data.get('fundamental', {})
        fund_score = 0
        
        # 规模评分
        size = fund.get('fund_size', 0)
        if 2 <= size <= 100:
            fund_score += 100
        elif size < 1:
            fund_score += 30
        elif size > 200:
            fund_score += 60
        else:
            fund_score += 80
        
        # 经理任期评分
        tenure = fund.get('manager_tenure', 0)
        if tenure >= 5:
            fund_score += 100
        elif tenure >= 3:
            fund_score += 80
        elif tenure >= 2:
            fund_score += 60
        else:
            fund_score += 40
        
        scores['fundamental'] = fund_score / 2
        
        # 持仓集中度评分
        style = input_data.get('style', {})
        top10 = style.get('top10_ratio', 50)
        if top10 < 30:
            scores['style'] = 100
        elif top10 < 50:
            scores['style'] = 80
        elif top10 < 70:
            scores['style'] = 60
        else:
            scores['style'] = 40
        
        # 动量评分（简化）
        scores['momentum'] = 50  # 需要更多数据
        
        # 综合评分
        total_score = (
            self.weights['performance'] * scores['performance'] +
            self.weights['risk'] * scores['risk'] +
            self.weights['fundamental'] * scores['fundamental'] +
            self.weights['style'] * scores['style'] +
            self.weights['momentum'] * scores['momentum']
        )
        
        # 生成建议
        if total_score >= 85:
            recommendation = 'STRONG_BUY'
            confidence = 5
        elif total_score >= 75:
            recommendation = 'BUY'
            confidence = 4
        elif total_score >= 65:
            recommendation = 'HOLD'
            confidence = 3
        elif total_score >= 50:
            recommendation = 'WATCH'
            confidence = 2
        else:
            recommendation = 'AVOID'
            confidence = 1
        
        return {
            'total_score': round(total_score, 2),
            'detail_scores': scores,
            'recommendation': recommendation,
            'confidence': confidence,
            'confidence_stars': '★' * confidence + '☆' * (5 - confidence)
        }
```

---

## 六、数据存储模块

### 6.1 数据存储器

```python
# src/storage/fund_storage.py

import json
import pandas as pd
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)


class FundDataStorage:
    """
    基金数据存储器
    
    存储结构：
    data/
    ├── funds/
    │   ├── fund_list.json          # 基金列表缓存
    │   ├── fund_details/           # 基金详情
    │   │   ├── 000001.json
    │   │   └── ...
    │   └── nav_history/            # 净值历史
    │       ├── 000001.csv
    │       └── ...
    ├── scores/
    │   ├── latest_scores.json      # 最新评分
    │   └── history/                # 历史评分
    │       ├── scores_20260130.json
    │       └── ...
    └── reports/
        └── ...
    """
    
    def __init__(self, data_dir: str = 'data'):
        self.data_dir = Path(data_dir)
        self._ensure_dirs()
    
    def _ensure_dirs(self):
        """确保目录结构存在"""
        dirs = [
            self.data_dir / 'funds',
            self.data_dir / 'funds' / 'fund_details',
            self.data_dir / 'funds' / 'nav_history',
            self.data_dir / 'scores',
            self.data_dir / 'scores' / 'history',
            self.data_dir / 'reports',
        ]
        for d in dirs:
            d.mkdir(parents=True, exist_ok=True)
    
    def save_fund_list(self, fund_list: pd.DataFrame):
        """保存基金列表"""
        path = self.data_dir / 'funds' / 'fund_list.json'
        fund_list.to_json(path, orient='records', force_ascii=False, indent=2)
        logger.info(f"保存基金列表到 {path}, 共 {len(fund_list)} 只")
    
    def load_fund_list(self) -> pd.DataFrame:
        """加载基金列表"""
        path = self.data_dir / 'funds' / 'fund_list.json'
        if path.exists():
            return pd.read_json(path)
        return pd.DataFrame()
    
    def save_fund_detail(self, fund_code: str, detail: Dict):
        """保存基金详情"""
        path = self.data_dir / 'funds' / 'fund_details' / f'{fund_code}.json'
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(detail, f, ensure_ascii=False, indent=2, default=str)
    
    def load_fund_detail(self, fund_code: str) -> Optional[Dict]:
        """加载基金详情"""
        path = self.data_dir / 'funds' / 'fund_details' / f'{fund_code}.json'
        if path.exists():
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return None
    
    def save_nav_history(self, fund_code: str, nav_df: pd.DataFrame):
        """保存净值历史"""
        path = self.data_dir / 'funds' / 'nav_history' / f'{fund_code}.csv'
        nav_df.to_csv(path, index=False, encoding='utf-8')
    
    def load_nav_history(self, fund_code: str) -> pd.DataFrame:
        """加载净值历史"""
        path = self.data_dir / 'funds' / 'nav_history' / f'{fund_code}.csv'
        if path.exists():
            return pd.read_csv(path)
        return pd.DataFrame()
    
    def save_scores(self, scores: List[Dict]):
        """保存评分结果"""
        # 保存最新评分
        latest_path = self.data_dir / 'scores' / 'latest_scores.json'
        with open(latest_path, 'w', encoding='utf-8') as f:
            json.dump({
                'generated_at': datetime.now().isoformat(),
                'count': len(scores),
                'scores': scores
            }, f, ensure_ascii=False, indent=2)
        
        # 保存历史
        date_str = datetime.now().strftime('%Y%m%d')
        history_path = self.data_dir / 'scores' / 'history' / f'scores_{date_str}.json'
        with open(history_path, 'w', encoding='utf-8') as f:
            json.dump(scores, f, ensure_ascii=False, indent=2)
        
        logger.info(f"保存评分结果, 共 {len(scores)} 只基金")
    
    def load_latest_scores(self) -> Dict:
        """加载最新评分"""
        path = self.data_dir / 'scores' / 'latest_scores.json'
        if path.exists():
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
```

---

## 七、主程序流程

### 7.1 完整工作流程

```python
# src/main_workflow.py

from collector.fund_data_collector import FundDataCollector
from model.model_adapter import FundScoringModelAdapter
from storage.fund_storage import FundDataStorage
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class FundAnalysisWorkflow:
    """
    完整的基金分析工作流
    """
    
    def __init__(self):
        self.collector = FundDataCollector()
        self.adapter = FundScoringModelAdapter()
        self.storage = FundDataStorage()
    
    def run_full_analysis(
        self, 
        limit: int = None,
        fund_types: List[str] = None
    ) -> Dict:
        """
        运行完整分析流程
        
        Args:
            limit: 限制分析基金数量（用于测试）
            fund_types: 限制基金类型
        """
        logger.info("=" * 50)
        logger.info("开始基金分析流程")
        logger.info("=" * 50)
        
        # Step 1: 采集基金列表
        logger.info("Step 1: 采集基金列表")
        fund_list = self.collector.collect_all_funds(filter_purchasable=True)
        
        # 类型过滤
        if fund_types:
            fund_list = fund_list[
                fund_list['type'].str.contains('|'.join(fund_types), na=False)
            ]
        
        # 数量限制
        if limit:
            fund_list = fund_list.head(limit)
        
        self.storage.save_fund_list(fund_list)
        logger.info(f"获取到 {len(fund_list)} 只可分析基金")
        
        # Step 2: 采集详细数据
        logger.info("Step 2: 采集基金详细数据")
        fund_codes = fund_list['基金代码'].tolist()
        
        # 批量采集（控制并发）
        details = self.collector.batch_collect_details(
            fund_codes, 
            max_workers=3
        )
        
        # 保存详情
        for code, detail in details.items():
            if 'error' not in detail:
                self.storage.save_fund_detail(code, detail)
        
        # Step 3: 计算评分
        logger.info("Step 3: 计算基金评分")
        scores = []
        
        for code, detail in details.items():
            if 'error' in detail:
                continue
            
            try:
                # 转换为模型输入
                input_data = self.adapter.prepare_model_input(detail)
                
                # 计算评分
                score_result = self.adapter.calculate_score(input_data)
                
                scores.append({
                    'code': code,
                    'name': input_data.get('name'),
                    **score_result,
                    'key_metrics': {
                        'return_1y': input_data.get('performance', {}).get('return_1y'),
                        'sharpe': input_data.get('risk', {}).get('sharpe_ratio'),
                        'max_drawdown': input_data.get('risk', {}).get('max_drawdown'),
                    }
                })
            except Exception as e:
                logger.error(f"计算基金 {code} 评分失败: {e}")
        
        # Step 4: 排序并保存
        logger.info("Step 4: 生成推荐列表")
        scores.sort(key=lambda x: x['total_score'], reverse=True)
        self.storage.save_scores(scores)
        
        # 生成统计
        result = {
            'generated_at': datetime.now().isoformat(),
            'total_analyzed': len(scores),
            'strong_buy': len([s for s in scores if s['recommendation'] == 'STRONG_BUY']),
            'buy': len([s for s in scores if s['recommendation'] == 'BUY']),
            'hold': len([s for s in scores if s['recommendation'] == 'HOLD']),
            'watch': len([s for s in scores if s['recommendation'] == 'WATCH']),
            'avoid': len([s for s in scores if s['recommendation'] == 'AVOID']),
            'top_10': scores[:10],
        }
        
        logger.info("=" * 50)
        logger.info("分析完成")
        logger.info(f"强烈推荐: {result['strong_buy']} 只")
        logger.info(f"推荐买入: {result['buy']} 只")
        logger.info(f"可以持有: {result['hold']} 只")
        logger.info("=" * 50)
        
        return result
    
    def run_quick_analysis(self, fund_codes: List[str]) -> List[Dict]:
        """
        快速分析指定基金
        """
        scores = []
        
        for code in fund_codes:
            try:
                detail = self.collector.collect_fund_detail(code)
                input_data = self.adapter.prepare_model_input(detail)
                score_result = self.adapter.calculate_score(input_data)
                
                scores.append({
                    'code': code,
                    'name': input_data.get('name'),
                    **score_result
                })
            except Exception as e:
                logger.error(f"分析基金 {code} 失败: {e}")
        
        return sorted(scores, key=lambda x: x['total_score'], reverse=True)


# 使用示例
if __name__ == '__main__':
    workflow = FundAnalysisWorkflow()
    
    # 完整分析（限制100只测试）
    result = workflow.run_full_analysis(limit=100, fund_types=['指数'])
    
    # 打印Top 10
    print("\n===== Top 10 推荐基金 =====")
    for i, fund in enumerate(result['top_10'], 1):
        print(f"{i}. {fund['code']} {fund['name']}")
        print(f"   评分: {fund['total_score']} {fund['confidence_stars']}")
        print(f"   建议: {fund['recommendation']}")
        print()
```

---

## 八、定时任务配置

### 8.1 定时更新脚本

```python
# scheduler_fund_analysis.py

from apscheduler.schedulers.blocking import BlockingScheduler
from apscheduler.triggers.cron import CronTrigger
from src.main_workflow import FundAnalysisWorkflow
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def daily_analysis_job():
    """每日分析任务"""
    logger.info("开始执行每日基金分析任务")
    
    workflow = FundAnalysisWorkflow()
    
    # 分类分析
    # 1. 指数基金
    result_index = workflow.run_full_analysis(fund_types=['指数', '联接'])
    
    # 2. 主动股票基金
    result_stock = workflow.run_full_analysis(fund_types=['股票'], limit=200)
    
    # 3. 混合基金
    result_mixed = workflow.run_full_analysis(fund_types=['混合'], limit=200)
    
    logger.info("每日分析任务完成")


def main():
    scheduler = BlockingScheduler()
    
    # 每天18:30执行分析（净值更新后）
    scheduler.add_job(
        daily_analysis_job,
        CronTrigger(hour=18, minute=30),
        id='daily_fund_analysis',
        name='每日基金分析'
    )
    
    logger.info("定时任务调度器已启动")
    logger.info("每日18:30执行基金分析")
    
    try:
        scheduler.start()
    except KeyboardInterrupt:
        logger.info("调度器已停止")


if __name__ == '__main__':
    main()
```

---

## 九、依赖清单

### 9.1 Python依赖

```txt
# requirements_fund_collector.txt

# 数据采集
akshare>=1.12.0
requests>=2.28.0
beautifulsoup4>=4.11.0
lxml>=4.9.0

# 数据处理
pandas>=2.0.0
numpy>=1.24.0

# 定时任务
apscheduler>=3.10.0

# 并发处理
concurrent-futures>=3.1.1  # Python 3.2+ 内置

# 日志
loguru>=0.7.0  # 可选，增强日志
```

### 9.2 安装命令

```bash
pip install akshare requests pandas numpy apscheduler
```

---

## 十、注意事项与风险提示

### 10.1 技术注意事项

1. **请求频率限制**
   - 天天基金API建议间隔0.3秒以上
   - AKShare建议间隔0.5秒以上
   - 大批量采集建议使用代理池

2. **数据准确性**
   - 实时估值仅供参考，实际以收盘净值为准
   - 持仓数据有滞后（季报更新）
   - 不同数据源可能存在差异

3. **异常处理**
   - 网络异常需重试
   - 数据缺失需标记
   - 定期验证数据质量

### 10.2 投资风险提示

1. **模型局限性**
   - 历史数据不代表未来表现
   - 量化模型可能存在过拟合
   - 市场环境变化可能导致模型失效

2. **操作建议**
   - 模型结果仅供参考，需结合个人判断
   - 建议分散投资，控制单只基金仓位
   - 定期复盘模型效果，适时调整

---

## 十一、扩展规划

| 版本 | 功能 | 说明 |
|-----|------|-----|
| v1.1 | 增加更多数据源 | 同花顺、Choice等 |
| v1.2 | 机器学习优化 | XGBoost/LightGBM预测 |
| v1.3 | 回测系统 | 验证模型历史表现 |
| v2.0 | Web界面 | 可视化Dashboard |
| v2.1 | 自动交易对接 | 券商API（需合规） |

---

*文档版本：1.0*  
*更新日期：2026年1月*
